package packet

import (
	"bytes"
	"fmt"
	"io"
	"log"

	"github.com/airforce270/mc-srv/packet/id"
	"github.com/airforce270/mc-srv/read"
	"github.com/airforce270/mc-srv/write"
	"github.com/google/uuid"
)

// Packet sent to initiate login.
type LoginStart struct {
	Header
	// Player's username.
	PlayerName string
	// The UUID of the player logging in.
	PlayerUUID uuid.UUID
}

func (LoginStart) Name() string { return "LoginStart" }

// ReadLoginStart reads a Login Start packet from the reader.
// https://wiki.vg/Protocol#Login_Start
func ReadLoginStart(r io.Reader, header Header) (LoginStart, error) {
	p := LoginStart{Header: header}

	var err error

	p.PlayerName, err = read.String(r)
	if err != nil {
		return p, fmt.Errorf("failed to read player name: %w", err)
	}

	p.PlayerUUID, err = read.UUID(r)
	if err != nil {
		return p, fmt.Errorf("failed to read player UUID: %w", err)
	}

	return p, nil
}

// Packet to the client to start encryption.
// https://wiki.vg/Protocol#Encryption_Request
type EncryptionRequest struct {
	// Server ID - is usually empty.
	ServerID string
	// Length of Public Key.
	PublicKeyLength int32
	// The server's public key, in bytes.
	PublicKey []byte
	// Length of Verify Token. Always 4 for Notchian servers.
	VerifyTokenLength int32
	// A sequence of random bytes generated by the server.
	VerifyToken []byte
}

func (EncryptionRequest) Name() string { return "EncryptionRequest" }

// Write writes the EncryptionRequest to the writer.
func (r EncryptionRequest) Write(w io.Writer) error {
	var buf bytes.Buffer

	if err := write.String(&buf, r.ServerID); err != nil {
		return fmt.Errorf("failed to write server ID: %w", err)
	}
	if err := write.VarInt(&buf, r.PublicKeyLength); err != nil {
		return fmt.Errorf("failed to write public key length: %w", err)
	}
	if err := write.Bytes(&buf, r.PublicKey); err != nil {
		return fmt.Errorf("failed to write public key: %w", err)
	}
	if err := write.VarInt(&buf, r.VerifyTokenLength); err != nil {
		return fmt.Errorf("failed to write verify token length: %w", err)
	}
	if err := write.Bytes(&buf, r.VerifyToken); err != nil {
		return fmt.Errorf("failed to write verify token: %w", err)
	}

	if err := writePacket(w, id.EncryptionRequest, &buf); err != nil {
		return fmt.Errorf("failed to write packet: %w", err)
	}

	return nil
}

// Packet sent to complete encryption.
type EncryptionResponse struct {
	Header
	// Length of Shared Secret.
	SharedSecretLength int32
	// Shared Secret value, encrypted with the server's public key.
	SharedSecret []byte
	// Length of Verify Token.
	VerifyTokenLength int32
	// Verify Token value,
	// encrypted with the same public key as the shared secret.
	VerifyToken []byte
}

func (EncryptionResponse) Name() string { return "EncryptionResponse" }

// ReadEncryptionResponse reads an Encryption Response packet from the reader.
// https://wiki.vg/Protocol#Encryption_Response
func ReadEncryptionResponse(r io.Reader, header Header) (EncryptionResponse, error) {
	p := EncryptionResponse{Header: header}

	var err error

	p.SharedSecretLength, err = read.VarInt(r)
	if err != nil {
		return p, fmt.Errorf("failed to read shared secret length: %w", err)
	}

	p.SharedSecret, err = read.Bytes(r, int(p.SharedSecretLength))
	if err != nil {
		return p, fmt.Errorf("failed to read shared secret: %w", err)
	}

	p.VerifyTokenLength, err = read.VarInt(r)
	if err != nil {
		return p, fmt.Errorf("failed to read verify token length: %w", err)
	}

	p.VerifyToken, err = read.Bytes(r, int(p.VerifyTokenLength))
	if err != nil {
		return p, fmt.Errorf("failed to read verify token: %w", err)
	}

	return p, nil
}

// Packet to the client to indicate login succeeded.
// https://wiki.vg/Protocol#Login_Success
type LoginSuccess struct {
	// Player's UUID (?)
	UUID uuid.UUID
	// Player's username (?)
	Username string
	// Number of elements in Properties.
	PropertyCount int32
	// Properties contains some Properties (?)
	Properties []LoginSuccessProperty
}

// A LoginSuccessProperty is a property sent in the LoginSuccess packet.
type LoginSuccessProperty struct {
	// Property name.
	Name string
	// Property value.
	Value string
	// Whether the property is signed (?)
	IsSigned bool
	// Only if IsSigned is true
	Signature *string
}

func (LoginSuccess) Name() string { return "LoginSuccess" }

// Write writes the LoginSuccess to the writer.
func (s LoginSuccess) Write(w io.Writer, logger *log.Logger) error {
	var buf bytes.Buffer

	if err := write.UUID(&buf, s.UUID); err != nil {
		return fmt.Errorf("failed to write uuid: %w", err)
	}
	if err := write.String(&buf, s.Username); err != nil {
		return fmt.Errorf("failed to write username: %w", err)
	}
	if err := write.VarInt(&buf, s.PropertyCount); err != nil {
		return fmt.Errorf("failed to write property count: %w", err)
	}

	for _, p := range s.Properties {
		if err := write.String(&buf, p.Name); err != nil {
			return fmt.Errorf("failed to write property.name: %w", err)
		}
		if err := write.String(&buf, p.Value); err != nil {
			return fmt.Errorf("failed to write property.value: %w", err)
		}
		if err := write.Bool(&buf, p.IsSigned); err != nil {
			return fmt.Errorf("failed to write property.is signed: %w", err)
		}
		if p.IsSigned {
			if err := write.String(&buf, *p.Signature); err != nil {
				return fmt.Errorf("failed to write property.signature: %w", err)
			}
		}
	}

	if err := writePacket(w, id.LoginSuccess, &buf); err != nil {
		return fmt.Errorf("failed to write packet: %w", err)
	}
	return nil
}

// Packet sent by the client to acknowledge login success..
type LoginAcknowledgement struct {
	Header
}

func (LoginAcknowledgement) Name() string { return "LoginAcknowledgement" }
